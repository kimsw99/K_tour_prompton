<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>Tmap Route</title>
    <!-- Të§µ SDKëŠ” ë¶€ëª¨ í˜ì´ì§€ì—ì„œ ì´ë¯¸ ë¡œë“œë¨ -->
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div id="map_div" style="width:100%; height:100%;"></div>
    <script>
      const route = (() => {
        try {
          const raw = new URLSearchParams(location.search).get("route");
          return JSON.parse(decodeURIComponent(raw));
        } catch {
          return [];
        }
      })();

      // API í‚¤ëŠ” URL íŒŒë¼ë¯¸í„°ì—ì„œ ê°€ì ¸ì˜¤ê¸°
      const appKey = new URLSearchParams(location.search).get("appKey");
      
      if (!appKey) {
        console.error("ğŸš¨ Të§µ API í‚¤ê°€ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
        document.getElementById("map_div").innerHTML = "<div style='padding: 20px; text-align: center;'>API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤.</div>";
      } else {
        // Të§µ SDKê°€ ë¡œë“œë  ë•Œê¹Œì§€ ëŒ€ê¸° í›„ ì§€ë„ ì´ˆê¸°í™”
        function waitForTmap() {
          if (typeof Tmapv2 !== 'undefined') {
            initMap();
          } else {
            setTimeout(waitForTmap, 100);
          }
        }
        
        window.onload = waitForTmap;
      }

      function initMap() {
        if (!route || route.length < 2) return;

        const start = route[0];
        const end = route[route.length - 1];
        const passList = route.slice(1, -1);

        const map = new Tmapv2.Map("map_div", {
          center: new Tmapv2.LatLng(start.mapy, start.mapx),
          width: "100%",
          height: "100%",
          zoom: 15,
        });

        const bounds = new Tmapv2.LatLngBounds();

        route.forEach((point) => {
          const latLng = new Tmapv2.LatLng(point.mapy, point.mapx);
          new Tmapv2.Marker({
            position: latLng,
            map: map,
            title: point.title,
          });
          bounds.extend(latLng);
        });

        map.fitBounds(bounds); // âœ… ëª¨ë“  ë§ˆì»¤ê°€ ë³´ì´ê²Œ ì¡°ì •

        // ë„ë³´ ê²½ë¡œ API ìš”ì²­
        const headers = { appKey };
        const data = {
          startX: start.mapx,
          startY: start.mapy,
          endX: end.mapx,
          endY: end.mapy,
          startName: start.title,
          endName: end.title,
          reqCoordType: "WGS84GEO",
          resCoordType: "WGS84GEO",
        };

        if (passList.length > 0) {
          data.passList = passList.map(p => `${p.mapx},${p.mapy}`).join("_");
        }

        fetch("https://apis.openapi.sk.com/tmap/routes/pedestrian?version=1&format=json", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            appKey: appKey,
          },
          body: new URLSearchParams(data)
        })
          .then(res => res.json())
          .then(json => {
            const features = json.features;
            //ì¤‘ë³µ ê²½ë¡œ ì œê±°ë¥¼ ìœ„í•œ Setê³¼ ê²½ë¡œ ì €ì¥ì„ ìœ„í•œ ë°°ì—´
            const seen = new Set();
            const linePath = [];

            const getLineStringFromGeojson = (features, type) => {
              return features.filter(feature => feature.geometry.type === type);
            }
            const lineString = getLineStringFromGeojson(features, 'LineString');
            
            console.log("ğŸš€ ê²½ë¡œ API ì‘ë‹µ:", lineString);
            features
            .filter(f => f.geometry.type === "LineString")
            .forEach(f => {
              f.geometry.coordinates.forEach(([lng, lat]) => {
                // ì¢Œí‘œ ìˆœì„œ ìˆ˜ì • ë° ì •ë°€ë„ ì¡°ì •
                const key = `${lat.toFixed(6)},${lng.toFixed(6)}`;
                if (!seen.has(key)) {
                  seen.add(key);
                  linePath.push(new Tmapv2.LatLng(lat, lng));
                }
              });
            });
            console.log("ğŸš€ ê²½ë¡œ ì¢Œí‘œ:", linePath);
            /*features.forEach(f => {
              if (f.geometry.type === "LineString") {
                f.geometry.coordinates.forEach(coord => {
                  const latLng = new Tmapv2.LatLng(coord[1], coord[0]);
                  linePath.push(latLng);
                });
              }
            });
            */
            new Tmapv2.Polyline({
              path: linePath,
              strokeColor: "#ff86e1",
              strokeWeight: 5,
              map: map
            });
          })
          .catch(err => console.error("ğŸš¨ ê²½ë¡œ API ì˜¤ë¥˜:", err));
      }
    </script>
  </body>
</html>
